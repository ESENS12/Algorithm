'''
백준 알고리즘 1011 문제 풀이
작성자 ESENS
작성일 180323

이동은 앞뒤로 2칸
처음에는 -1 0 +1 이 가능하고
x 부터 y 까지 최소 이동거리 찾는데
마지막 이동거리는 1이여야 하므로
y-1까지의 이동거리를 찾아서 +1 해주면 된다.

이전에 이동한 값 = k
처음에는 k-1 , k , k+1 이지만 k가 0이므로 나머지 값은 의미가 없음

사실상 처음엔 1스텝 이동 가능 하고
2번째 스텝부터는 K+1만큼 이동이 가능하다

k ={{1}, {0,1,2}, {1,2,3}},
{{2,3,4} {3,4,5} {4,5,6}},
{{5,6,7} {6,7,8} {7,8,9}},
{{8,9,10} {9,10,11} {10,11,12}}

1=1
3=1 + 2
6=1 + 2 + 3
10=1 + 2 + 3 + 4
15=1 + 2 + 3 + 4 + 5

max(k) = 1,2,3,4,5...(k+1)
min(k) = 0,1,2,3,4...(k-1)

(0->3) = +1 + 1 + 1(1 2 3) 3번
(1->5) = +1 + 2 + 1(2 4 5) 3번
(0->5) = +1 + 2 + 1 + 1  (1 3 4 5) 4번
(45->50) = +1 + 2 + 1 + 1(46 48 49 50) 4번
(6->12) = +1 +2 +2 +1 (7 9 11 12) 4번
(10->17) = +1 + 2 + 2 + 1 + 1(11 13 15 16 17) 5번
(10->19) = +1 + 2 + 3 + 2 + 1 (11 13 16 18 19) 5번(거리 = 9)
(10->20) = +1 + 2 + 3 + 2 + 1 + 1(11 13 16 18 19 20) 6번(거리 = 10)
(10->21) = +1 + 2 + 3 + 2 + 2 + 1(11 13 16 18 20 21) 6번(거리 = 11)
(10->22) = +1 + 2 + 3 + 3 + 2 + 1(11 13 16 19 21 22) 6번(거리 = 12)
(10->30) = +1 + 2 + 3 + 4 + 4 + 3 + 2 + 1(11 13 16 20 24 27 29 30) 8번(거리 = 20)


증가 할 수 있는 경우 = 도착점-1 - 남은거리 >= 현재스텝에서 2까지의 거리
증가 할 수 없으면 현재까지의 스텝을 역순으로

도착점 - 출발점이 홀수이면 위 조건에 +1 해주면 되고
도착점 - 출발점이 짝수이면 위 조건에 부합한다

각 스텝의 제곱만큼 이동할 수 있음
1 = 1
2 = 4
3 = 9 까지..
각 스텝만큼 진행해서 최대 이동거리 를 뺀
나머지 / 최대이동거리 를 더해주면 된다
'''

def sepLine(datas):
    start = ""
    end = ""
    distance = 0
    max = 0
    #첫번째 스텝은 무조건 1
    step = 1;
    #이동거리 = 최대스텝 * 2 -1
    moving = 0
    for data in datas:
        data = data.split(" ")
        start = data[0]
        end = data[1]
        distance = int(end) - int(start)
        #print(start)
        #print(end)
        if distance < 2 :
            print(distance)
        #최대값은 2147483647 미만
        for i in range(1,distance):
            max = (i+1) * (i+1)
            #print(max)
            if(max > distance):
                max = (i*i)
                distance -= max
                moving = (i * 2) - 1
                #print("남은거리 : " + str(distance))
                #print("max = " + str(max))
                #print("이동거리 : " + str(moving))
                if distance == 1 :
                    print(moving + distance)
                    break
                else:
                    #print(round(distance/max))
                    #print(distance/max)
                    ans = round(distance / i) + moving
                    print(ans)
                    break

data = []

size = int(input())
for i in range (0,size):
    data.append(input())
sepLine(data)